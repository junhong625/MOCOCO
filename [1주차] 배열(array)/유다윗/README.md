# [1주차] 배열(array) by 유다윗
- 자료 구조
    - 연속 방식(contiguous): 메모리 공간 기반 -> 배열은 연속 방식의 기본이 되는 자료형
    - 연결 방식(link): 포인터 기반 -> 연결 리스트는 연결 방식의 가장 기본이 되는 자료형
- 배열
    - 작업(C 기준)
        1. 크기를 지정한다.
        2. 크기만큼의 연속된 메모리 공간을 할당 받는다.
        ``` C
        int arr[5] = {4, 7, 29, 0, 1}
        ```
    - 어느 위치에나 O(1)에 조회가 가능하다.
- 메모리와 포인터
    - 포인터: 메모리 영역을 1바이트 단위로 가리키는 주소이다.
    - 32비트 머신은 메모리 주소를 0에서 2^32-1밖에 표현할 수 없다. 또한 메모리를 4GB 이상 인식할 수 없다.
    - 64비트 머신은 2^64, 약 16EB(엑시바이트)라는 가상 메모리를 가리킬 수 있다.
- 동적 배열
    - 크기를 지정하지 않고 자동으로 resizing하는 배열
    - 파이썬에서는 리스트가 동적 배열 자료형이다.
    - 파이썬에는 정적 배열 자체가 없다.
    - 조회 또한 O(1)에 가능하다.
    - 분할 상환 분석에 따른 시간 복잡도를 설명하는 대표적인 자료형이다.

<br/>

## 문제
>leetcode: 1. Two sum
- 풀이1: 브루트 포스로 계산(Brute-Force)
    - 배열을 반복하며 모든 조합을 더해 일일이 확인하는 방식
    - 정답을 찾을 때까지 계속 진행한다.
    - 시간 복잡도: O(n^2)
    - 매우 느리다.
- 풀이2: in을 이용한 탐색
    - target - n이 존재하는지 판별하는 방식
    - 시간 복잡도 O(n)
    - **in은 파이썬 레벨에서 매번 값을 비교하는 것에 비해 훨씬 더 빨리 실행된다.**
- 풀이3: 첫 번째 수를 뺀 결과 키 조회
    - 키와 값을 바꿔서 딕셔너리로 저장 -> target에서 첫 번째 수를 뺸 결과를 키로 조회 -> 있을 시 해당 키의 value를 반환 -> 최종 결과
    - 조회가 평균적으로 O(1)에 가능하다.
- 풀이5: 투 포인터 이용
    - 왼쪽 포인터와 오른쪽 포인터의 합이 target보다 크면 오른쪽 포인터를 왼쪽으로 옮기고, 합이 target보다 작으면 왼쪽 포인터를 오른쪽으로 옮기면서 값을 조정한다.
    - 이 방식을 사용하려면 값이 정렬되어 있어야 한다.
    - 시간 복잡도는 O(n)이다.
    - 단, 인덱스를 찾는 문제에서는 사용하기 어렵다. 왜냐하면 정렬 시 인데스가 뒤섞이기 때문이다.

<br/>

>leetcode: 42. Trapping Rain Water
- 풀이1: 투 포인터를 최대로 이동
    - O(n)에 풀이가 가능하다.
    